<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Saturation problem · Magnetic Resonance Imaging</title><meta name="title" content="Saturation problem · Magnetic Resonance Imaging"/><meta property="og:title" content="Saturation problem · Magnetic Resonance Imaging"/><meta property="twitter:title" content="Saturation problem · Magnetic Resonance Imaging"/><meta name="description" content="Documentation for Magnetic Resonance Imaging."/><meta property="og:description" content="Documentation for Magnetic Resonance Imaging."/><meta property="twitter:description" content="Documentation for Magnetic Resonance Imaging."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Magnetic Resonance Imaging</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="bloch-equation.html">Bloch equation</a></li><li class="is-active"><a class="tocitem" href="saturation.html">Saturation problem</a><ul class="internal"><li><a class="tocitem" href="#Time-minimal-saturation-problem"><span>Time-minimal saturation problem</span></a></li><li><a class="tocitem" href="#Direct-method"><span>Direct method</span></a></li><li><a class="tocitem" href="#Indirect-method"><span>Indirect method</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/MagneticResonanceImaging.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/MagneticResonanceImaging.jl/blob/main/docs/src/saturation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="mri-saturation"><a class="docs-heading-anchor" href="#mri-saturation">Saturation problem in Magnetic Resonance Imaging</a><a id="mri-saturation-1"></a><a class="docs-heading-anchor-permalink" href="#mri-saturation" title="Permalink"></a></h1><h2 id="Time-minimal-saturation-problem"><a class="docs-heading-anchor" href="#Time-minimal-saturation-problem">Time-minimal saturation problem</a><a id="Time-minimal-saturation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Time-minimal-saturation-problem" title="Permalink"></a></h2><p>The time-minimal saturation problem is the following: starting from the North pole of the  Bloch ball, the goal is to reach in minimum time the center of the Bloch ball, which  corresponds at the final time to zero magnetization of the spin.</p><div class="admonition is-info" id="Time-minimal-saturation-problem-8c776b10f14bd699"><header class="admonition-header">Time-minimal saturation problem<a class="admonition-anchor" href="#Time-minimal-saturation-problem-8c776b10f14bd699" title="Permalink"></a></header><div class="admonition-body"><p>We define the <em>time-minimal saturation problem</em> as the following optimal control  problem:</p><p class="math-container">\[    \inf t_f, 
    \quad \text{s.t.} \quad u(\cdot) \in \mathcal{U}, \quad 
    t_f \ge 0 \quad \text{and} \quad q(t_f, N, u(\cdot)) = O,\]</p><p>where <span>$N = (0, 1)$</span> is the North pole, where <span>$O = (0,0)$</span> is the origin of the Bloch  ball and where <span>$t \mapsto q(t, q_0, u(\cdot))$</span>  is the unique maximal solution of the 2D control system <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>  associated to the control <span>$u(\cdot)$</span> and starting from the given initial condition <span>$q_0$</span>.</p></div></div><p>The <strong>inversion sequence</strong> <span>${\sigma_+} {\sigma_s^v}$</span>, that is a positive bang arc followed by a singular vertical arc with zero control, is the simplest way to go from <span>$N$</span> to <span>$O$</span>.  Is it optimal?</p><img src="./mri-resources/inversion_sequence.png" style="display: block; margin-left: auto; margin-right: auto;" width="500px">
<br><p>We have the following symmetry.</p><p><strong>Proposition.</strong> Let <span>$(y(\cdot), z(\cdot))$</span>, with associated control <span>$u(\cdot)$</span>, be a  trajectory solution of <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>. Then, <span>$(-y(\cdot), z(\cdot))$</span> with control <span>$-u(\cdot)$</span> is also solution of this system.</p><p>This discrete symmetry allows us to consider only trajectories inside the domain  <span>$\{y \le 0\}$</span> of the Bloch ball.</p><p>In order to solve numerically the problem, we need to set the parameters.  We introduce the practical cases in the following table. We give the relaxation times with  the associated <span>$(\gamma, \Gamma)$</span> parameters for <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz.  Note that in the experiments, <span>$\omega_\mathrm{max}$</span> may be chosen up to 15 000 Hz but we  consider the same value as in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><table><tr><th style="text-align: left"><strong>Name</strong></th><th style="text-align: left"><span>$T_1$</span></th><th style="text-align: left"><span>$T_2$</span></th><th style="text-align: left"><span>$\gamma$</span></th><th style="text-align: left"><span>$\Gamma$</span></th><th style="text-align: left"><span>$\delta=\gamma-\Gamma$</span></th></tr><tr><td style="text-align: left">Water</td><td style="text-align: left">2.5</td><td style="text-align: left">2.5</td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$0.0$</span></td></tr><tr><td style="text-align: left">Cerebrospinal Fluid</td><td style="text-align: left">2.0</td><td style="text-align: left">0.3</td><td style="text-align: left"><span>$2.4637e^{-03}$</span></td><td style="text-align: left"><span>$1.6425e^{-02}$</span></td><td style="text-align: left"><span>$-1.3961^{-02}$</span></td></tr><tr><td style="text-align: left">Deoxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.05</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$9.8548e^{-02}$</span></td><td style="text-align: left"><span>$-9.4898^{-02}$</span></td></tr><tr><td style="text-align: left">Oxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.2</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$-2.0987^{-02}$</span></td></tr><tr><td style="text-align: left">Gray cerebral matter</td><td style="text-align: left">0.92</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$5.3559e^{-03}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-4.3918^{-02}$</span></td></tr><tr><td style="text-align: left">White cerebral matter</td><td style="text-align: left">0.78</td><td style="text-align: left">0.09</td><td style="text-align: left"><span>$6.3172e^{-03}$</span></td><td style="text-align: left"><span>$5.4749e^{-02}$</span></td><td style="text-align: left"><span>$-4.8432^{-02}$</span></td></tr><tr><td style="text-align: left">Fat</td><td style="text-align: left">0.2</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-2.4637^{-02}$</span></td></tr><tr><td style="text-align: left">Brain</td><td style="text-align: left">1.062</td><td style="text-align: left">0.052</td><td style="text-align: left"><span>$4.6397e^{-03}$</span></td><td style="text-align: left"><span>$9.4758e^{-02}$</span></td><td style="text-align: left"><span>$-9.0118^{-02}$</span></td></tr><tr><td style="text-align: left">Parietal muscle</td><td style="text-align: left">1.2</td><td style="text-align: left">0.029</td><td style="text-align: left"><span>$4.1062e^{-03}$</span></td><td style="text-align: left"><span>$1.6991e^{-01}$</span></td><td style="text-align: left"><span>$-1.6580^{-02}$</span></td></tr></table><p>Table: Matter name with associated relaxation times in seconds and relative <span>$(\gamma, \Gamma)$</span> parameters with <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz and <span>$u_\mathrm{max} = 1$</span>.</p><div class="admonition is-info" id="Deoxygenated-blood-case-2b89bcd8da0a2109"><header class="admonition-header">Deoxygenated blood case<a class="admonition-anchor" href="#Deoxygenated-blood-case-2b89bcd8da0a2109" title="Permalink"></a></header><div class="admonition-body"><p>We consider the Deoxygenated blood case.  According to Theorem 3.6 from <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> the optimal solution is of the form  Bang-Singular-Bang-Singular (BSBS). The two bang arcs are with control <span>$u=1$</span>.  The first singular arc is contained in the horizontal line <span>$z=\gamma/2\delta$</span> while the second singular arc is contained in the vertical line <span>$y=0$</span>.  We propose in the following to retrieve this result numerically.</p></div></div><p>Let us first define the parameters with the two vector fields <span>$F_0$</span> and <span>$F_1$</span>.</p><pre><code class="language-julia hljs">import OptimalControl: ⋅
⋅(a::Number, b::Number) = a*b

# Blood case
T1 = 1.35 # s
T2 = 0.05

ω = 2π⋅32.3 # Hz
γ = 1/(ω⋅T1)
Γ = 1/(ω⋅T2)

δ = γ - Γ
zs = γ / 2δ # ordinate of the horizontal singular line

F0(y, z) = [-Γ⋅y, γ⋅(1-z)]
F1(y, z) = [-z, y]

q0 = [0, 1] # initial state: the North pole</code></pre><p>Then, we can define the problem with OptimalControl.</p><pre><code class="language-julia hljs">using OptimalControl

ocp = @def begin

    tf ∈ R, variable
    t ∈ [0, tf ], time
    q = (y, z) ∈ R², state
    u ∈ R, control

    y(t) ≤ 0.1 # for the symmetry

    q(0)  == q0
    q(tf) == [0, 0]

    -1 ≤ u(t) ≤ 1

    q̇(t) == F0(q(t)...) + u(t) * F1(q(t)...)

    tf → min

    tf ≥ 0

end</code></pre><h2 id="Direct-method"><a class="docs-heading-anchor" href="#Direct-method">Direct method</a><a id="Direct-method-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-method" title="Permalink"></a></h2><p>We start to solve the problem with a direct method. The problem is transcribed into a NLP optimization problem by OptimalControl. The NLP problem is then solved by the well-known solver Ipopt thanks to NLPModelsIpopt.</p><p>We first start with a coarse grid, with only 100 points. We provide an init consistent with a solution in the domain <span>$y \le 0$</span>.</p><pre><code class="language-julia hljs">using NLPModelsIpopt
N = 100
sol = solve(
    ocp;
    grid_size=N,
    init=(state=[-0.5, 0.0], ),
    disc_method=:gauss_legendre_2,
    print_level=4
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">▫ This is OptimalControl version v1.1.3 running with: direct, adnlp, ipopt.

▫ The optimal control problem is solved with CTDirect version v0.17.3.

   ┌─ The NLP is modelled with ADNLPModels and solved with NLPModelsIpopt.
   │
   ├─ Number of time steps⋅: 100
   └─ Discretisation scheme: gauss_legendre_2

Total number of variables............................:      703
                     variables with only lower bounds:        1
                variables with lower and upper bounds:      100
                     variables with only upper bounds:      101
Total number of equality constraints.................:      604
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 143

                                   (scaled)                 (unscaled)
Objective...............:   4.2714529345077786e+01    4.2714529345077786e+01
Dual infeasibility......:   7.2743894241611429e-13    7.2743894241611429e-13
Constraint violation....:   1.1102230246251565e-16    1.1102230246251565e-16
Variable bound violation:   9.9751860105357082e-09    9.9751860105357082e-09
Complementarity.........:   1.0000006641016691e-11    1.0000006641016691e-11
Overall NLP error.......:   1.0000006641016691e-11    1.0000006641016691e-11


Number of objective function evaluations             = 209
Number of objective gradient evaluations             = 133
Number of equality constraint evaluations            = 209
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 149
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 143
Total seconds in IPOPT                               = 4.911

EXIT: Optimal Solution Found.</code></pre><p>Then, we plot the solution thanks to Plots.</p><pre><code class="language-julia hljs">using Plots
plt = plot(sol; size=(700, 500), label=&quot;N = &quot;*string(N))</code></pre><img src="saturation-19b36812.svg" alt="Example block output"/><p>This rough approximation is then refine on a finer grid of 1000 points. This two steps resolution increases the speed of convergence. Note that we provide the previous solution as initialisation.</p><pre><code class="language-julia hljs">N = 1000
direct_sol = solve(
    ocp;
    grid_size=N,
    init=sol,
    disc_method=:gauss_legendre_2,
    print_level=4,
    tol=1e-12
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">▫ This is OptimalControl version v1.1.3 running with: direct, adnlp, ipopt.

▫ The optimal control problem is solved with CTDirect version v0.17.3.

   ┌─ The NLP is modelled with ADNLPModels and solved with NLPModelsIpopt.
   │
   ├─ Number of time steps⋅: 1000
   └─ Discretisation scheme: gauss_legendre_2

Total number of variables............................:     7003
                     variables with only lower bounds:        1
                variables with lower and upper bounds:     1000
                     variables with only upper bounds:     1001
Total number of equality constraints.................:     6004
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 55

                                   (scaled)                 (unscaled)
Objective...............:   4.2713711084173745e+01    4.2713711084173745e+01
Dual infeasibility......:   9.6456176379433600e-13    9.6456176379433600e-13
Constraint violation....:   2.7755575615628914e-16    2.7755575615628914e-16
Variable bound violation:   9.9883199489170238e-09    9.9883199489170238e-09
Complementarity.........:   5.0000406364690906e-13    5.0000406364690906e-13
Overall NLP error.......:   9.6456176379433600e-13    9.6456176379433600e-13


Number of objective function evaluations             = 79
Number of objective gradient evaluations             = 56
Number of equality constraint evaluations            = 79
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 57
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 55
Total seconds in IPOPT                               = 3.823

EXIT: Optimal Solution Found.</code></pre><p>We can compare both solutions. The BSBS structure is revelead even if the second bang arc is not clearly demonstrated.</p><pre><code class="language-julia hljs">plot!(plt, direct_sol; label=&quot;N = &quot;*string(N), color=2)</code></pre><img src="saturation-8edd2f96.svg" alt="Example block output"/><div class="admonition is-info" id="Code-for-plotting-in-the-Bloch-ball-62e42b27420c2159"><header class="admonition-header">Code for plotting in the Bloch ball<a class="admonition-anchor" href="#Code-for-plotting-in-the-Bloch-ball-62e42b27420c2159" title="Permalink"></a></header><div class="admonition-body"><p>We define a custom plot function for plotting the solution inside the Bloch ball.</p><details><summary>Click to unfold and get the code of the custom plot function.</summary><pre><code class="language-julia hljs">using Plots.PlotMeasures
function spin_plot(sol; kwargs...)

    y2 = cos(asin(zs))
    y1 = -y2

    t = time_grid(sol)
    q = state(sol)
    y = t -&gt; q(t)[1]
    z = t -&gt; q(t)[2]
    u = control(sol)

    # styles
    Bloch_ball_style = (seriestype=[:shape, ], color=:grey, linecolor=:black,
        legend=false, fillalpha=0.1, aspect_ratio=1)
    state_style = (label=:none, linewidth=2, color=1)
    initial_point_style = (seriestype=:scatter, color=:1, linewidth=0)
    axis_style = (color=:black, linewidth=0.5)
    control_style = (label=:none, linewidth=2, color=1)

    # state trajectory in the Bloch ball
    θ = LinRange(0, 2π, 100)
    state_plt = plot(cos.(θ), sin.(θ); Bloch_ball_style...) # Bloch ball
    plot!(state_plt, [-1, 1], [ 0,  0]; axis_style...)      # horizontal axis
    plot!(state_plt, [ 0, 0], [-1,  1]; axis_style...)      # vertical axis
    plot!(state_plt, [y1, y2], [zs, zs]; linestyle=:dash, axis_style...) # singular line
    plot!(state_plt, y.(t), z.(t); state_style...)
    plot!(state_plt, [0], [1]; initial_point_style...)
    plot!(state_plt; xlims=(-1.1, 0.1), ylims=(-0.1, 1.1), xlabel=&quot;y&quot;, ylabel=&quot;z&quot;)

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

    return plot(state_plt, control_plt; layout=(1, 2), leftmargin=15px, bottommargin=15px, kwargs...)

end</code></pre></details></div></div><p>Below, we plot the solution inside the Bloch ball. The first bang arc drives the trajectory to the horizontal singular line <span>$z = \gamma / (2\delta)$</span>, shown as a dashed line. The second bang arc is very short, which makes it difficult to capture accurately unless the grid is sufficiently fine. In the next section, we introduce an indirect method to refine this approximation.</p><pre><code class="language-julia hljs">spin_plot(direct_sol; size=(800, 400))</code></pre><img src="saturation-e48eb863.svg" alt="Example block output"/><p>To make the indirect method converge we need a good initial guess. We extract below the useful information from the direct solution to provide an initial guess for the indirect method. We need the initial costate together with the switching times between bang and singular arcs and the final time.</p><pre><code class="language-julia hljs">t  = time_grid(direct_sol)
q  = state(direct_sol)
p  = costate(direct_sol)
u  = control(direct_sol)
tf = variable(direct_sol)

t0 = 0
pz0 = p(t0)[2]

t_bang_1 = t[ (abs.(u.(t)) .≥ 0.5) .&amp; (t .≤  5)]
t_bang_2 = t[ (abs.(u.(t)) .≥ 0.5) .&amp; (t .≥ 35)]
t1 = max(t_bang_1...)
t2 = min(t_bang_2...)
t3 = max(t_bang_2...)

q1, p1 = q(t1), p(t1)
q2, p2 = q(t2), p(t2)
q3, p3 = q(t3), p(t3)

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pz0 = -10.138145104720211
t1 = 1.6231210211986022
t2 = 37.118214932146984
t3 = 37.545352042988725
tf = 42.713711084173745</code></pre><h2 id="Indirect-method"><a class="docs-heading-anchor" href="#Indirect-method">Indirect method</a><a id="Indirect-method-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-method" title="Permalink"></a></h2><p>We introduce the pseudo-Hamiltonian</p><p class="math-container">\[H(q, p, u) = H_0(q, p) + u\, H_1(q, p)\]</p><p>where <span>$H_0(q, p) = p \cdot F_0(q)$</span> and <span>$H_1(q, p) = p \cdot F_1(q)$</span> are both Hamiltonian lifts. According to the maximisation condition from the <a href="https://en.wikipedia.org/wiki/Pontryagin%27s_maximum_principle">Pontryagin Maximum Principle</a> (PMP), a bang arc occurs when <span>$H_1$</span> is nonzero and of constant sign along the arc. On the contrary the singular arcs are contained in <span>$H_1 = 0$</span>. If  <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> along an arc then its derivative is also zero. Thus, along a singular arc we have also</p><p class="math-container">\[\frac{\mathrm{d}}{\mathrm{d}t} H_1(q(t), p(t)) = 
\{H_0, H_1\}(q(t), p(t)) = 0,\]</p><p>where <span>$\{H_0, H_1\}$</span> is the Poisson bracket of <span>$H_0$</span> and <span>$H_1$</span>.</p><div class="admonition is-info" id="Lie-and-Poisson-brackets-3e8b7ceb19eced"><header class="admonition-header">Lie and Poisson brackets<a class="admonition-anchor" href="#Lie-and-Poisson-brackets-3e8b7ceb19eced" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$F_0$</span>, <span>$F_1$</span> be two smooth vector fields on a smooth manifold <span>$M$</span> and <span>$f$</span> a smooth function on <span>$M$</span>. Let <span>$x$</span> be local coordinates. The <em>Lie bracket</em> of <span>$F_0$</span> and <span>$F_1$</span> is given by </p><p class="math-container">\[    [F_0,F_1] \coloneqq  F_0 \cdot F_1 - F_1 \cdot F_0,\]</p><p>with <span>$(F_0 \cdot F_1)(x) = \mathrm{d} F_1(x) \cdot F_0(x)$</span>. The <em>Lie derivative</em> <span>$\mathcal{L}_{F_0} f$</span> of <span>$f$</span> along <span>$F_0$</span> is simply written <span>$F_0\cdot f$</span>. Denoting <span>$H_0$</span>, <span>$H_1$</span> the Hamiltonian lifts of <span>$F_0$</span>, <span>$F_1$</span>, then the <em>Poisson bracket</em> of <span>$H_0$</span> and <span>$H_1$</span> is</p><p class="math-container">\[    \{H_0,H_1\}  \coloneqq  \vec{H_0} \cdot H_1.\]</p><p>We also use the notation <span>$H_{01}$</span> (resp. <span>$F_{01}$</span>) to write the bracket <span>$\{H_0,H_1\}$</span> (resp. <span>$[F_0,F_1]$</span>) and so forth. Besides, since <span>$H_0$</span>, <span>$H_1$</span> are Hamiltonian lifts, we have <span>$\{H_0,H_1\}= p \cdot [F_0,F_1]$</span>.</p></div></div><div class="admonition is-info" id="Code-for-plotting-the-switching-function-and-its-derivative-621ab70bd8b22c14"><header class="admonition-header">Code for plotting the switching function and its derivative<a class="admonition-anchor" href="#Code-for-plotting-the-switching-function-and-its-derivative-621ab70bd8b22c14" title="Permalink"></a></header><div class="admonition-body"><p>We define a function for plotting the switching function <span>$t \mapsto H_1(q(t), p(t))$</span> and its derivative along the solution computed by the direct method.</p><details><summary>Click to unfold and get the code of the function.</summary><pre><code class="language-julia hljs">function switching_plot(sol, H1, H01; kwargs...)

    t  = time_grid(sol)
    u  = control(sol)
    q  = state(sol)
    p  = costate(sol)
    tf = t[end]
    φ(t) = H1(q(t), p(t))       # switching function
    dφ(t) = H01(q(t), p(t))     # derivative of the switching function

    # styles
    axis_style = (color=:black, linewidth=0.5, label=false)
    control_style = (label=:none, linewidth=2, color=1)

    # switching function
    switching_plt = plot()
    plot!(switching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(switching_plt, t, φ, label=&quot;H1(q(t), p(t))&quot;, xlabel=&quot;t&quot;, linewidth=2)
    plot!(switching_plt; xlims=(0, tf))

    # derivative of the switching function
    dswitching_plt = plot()
    plot!(dswitching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(dswitching_plt, t, dφ, label=&quot;H01(q(t), p(t))&quot;, xlabel=&quot;t&quot;, linewidth=2)
    plot!(dswitching_plt; xlims=(0, tf))

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

    return plot(switching_plt, dswitching_plt, control_plt; layout=(3, 1), kwargs...)
end</code></pre></details></div></div><p>We can notice on the plots below that maximisation condition from the PMP is not satisfied. We can see that the switching function becomes negative along the first bang arc but there is no switching from the control plot. Besides, we can see that along the first singular arc, the switching function is not always zero.</p><pre><code class="language-julia hljs">H0 = Lift(q -&gt; F0(q...))
H1 = Lift(q -&gt; F1(q...))
H01  = @Lie { H0, H1 }

switching_plot(direct_sol, H1, H01; size=(700, 800))</code></pre><img src="saturation-bff2fd49.svg" alt="Example block output"/><p>We aim to compute a better approximation of the solution thanks to indirect shooting. To do so, we need to define the three different flows associated to the three different  control laws in feedback form: bang control, singular control along the horizontal line and singular control along the vertical line. </p><div class="admonition is-info" id="Note-7eb04a3bb9d48c15"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7eb04a3bb9d48c15" title="Permalink"></a></header><div class="admonition-body"><p>Let us recall that <span>$\delta = \gamma - \Gamma$</span>. Then, for any <span>$q = (y,z)$</span> we have:</p><p class="math-container">\[    \begin{aligned}
        F_{01}(q) &amp;= 
        -(\gamma - \delta z) \frac{\partial}{\partial y} + 
        \delta y \frac{\partial}{\partial z}, \\[0.5em]
        F_{001}(q) &amp;= 
        \left( \gamma\, (\gamma - 2\Gamma) - 
        \delta^2 z\right)\frac{\partial}{ \partial y} + 
        \delta^2 y \frac{\partial}{\partial z}, \\[0.5em]
        F_{101}(q) &amp;= 
        2 \delta y \frac{\partial}{\partial y} + 
        (\gamma - 2 \delta z) \frac{\partial}{\partial z}.
    \end{aligned}\]</p><p>Along a singular arc, we have <span>$H_1 = H_{01} = 0$</span>, that is <span>$p \cdot F_1 = p \cdot F_{01} = 0$</span>. Since, <span>$p$</span> is of dimension 2 and is nonzero, then we have <span>$\det(F_1, F_{01}) = y ( \gamma - 2 \delta z) = 0$</span>. This gives us the two singular lines. </p><p>Differentiating <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> a second time along a singular arc gives</p><p class="math-container">\[    H_{001}(q(t), p(t)) + u(t)\, H_{101}(q(t), p(t)) = 0,\]</p><p>that is <span>$p(t)$</span> is orthogonal to <span>$F_{001}(q(t)) + u(t)\, F_{101}(q(t))$</span>. Hence, the singular control is given by</p><p class="math-container">\[    \det(F_1(q(t)), F_{001}(q(t))) + u(t) \, \det(F_1(q(t)), F_{101}(q(t))) = 0.\]</p><p>For <span>$y=0$</span>, <span>$\det(F_1(q), F_{101}(q))$</span> is zero and thus the singular control is zero. We denote it <span>$u_0 \coloneqq 0$</span>. Along the horizontal singular line, that is for <span>$z=\gamma/2\delta$</span>,  the control is given by </p><p class="math-container">\[    u_s(y) \coloneqq \gamma (2\Gamma - \gamma) / (2 \delta y).\]</p><p>Note that we could have defined the singular control with the Hamiltonian lifts <span>$H_{001}$</span> and <span>$H_{101}$</span>. See the <a href="https://control-toolbox.org/Tutorials.jl/stable/tutorial-goddard.html">Goddard tutorial</a> for an example of such a computation.</p></div></div><pre><code class="language-julia hljs">using OrdinaryDiffEq

# Controls
u0 = 0                   # off control: vertical singular line
u1 = 1                   # positive bang control
us(y) = γ⋅(2Γ−γ)/(2δ⋅y)  # singular control: horizontal line

# Flows
options = (abstol=1e-14, reltol=1e-10)

f0 = Flow(ocp, (q, p, tf) -&gt; u0      ; options...)
f1 = Flow(ocp, (q, p, tf) -&gt; u1      ; options...)
fs = Flow(ocp, (q, p, tf) -&gt; us(q[1]); options...)</code></pre><p>With the previous flows, we can define the shooting function considering the sequence given by the direct method: Bang-Singular-Bang-Singular. There are 3 switching times <span>$t_1$</span>, <span>$t_2$</span> and <span>$t_3$</span>. The final time <span>$t_f$</span> is unknown such as the initial costate. To reduce the sensitivy of the shooting function we also consider the states and costates at the switching times as unknowns and we add some matching conditions.</p><p>Note that the final time is free, hence, in the normal case, <span>$H = -p^0 = 1$</span> along the solution of the PMP. Considering this condition at the initial time (<span>$H$</span> is constant since the system is autonomous), we obtain <span>$p_y(0) = -1$</span>. At the entrance of the singular arcs, we must satisfy <span>$H_1 = H_{01} = 0$</span>. For the first singular arc, this leads to the conditions </p><p class="math-container">\[    - p_y(t_1) z_s + p_z(t_1) y(t_1) = z(t_1) - z_s = 0.\]</p><p>At the entrance of the second singular arc, we have</p><p class="math-container">\[    p_y(t_3) = y(t_3) = 0.\]</p><p>Finally, the solution has to satisfy the final condition  <span>$q(t_f) = (y(t_f), z(t_f)) = (0, 0)$</span>. Since, the last singular arc is contained in <span>$y=0$</span>, the condition <span>$y(t_f)=0$</span> is redundant and  so we only need to check that <span>$z(t_f) = 0$</span>.</p><p>Altogether, this leads to the following shooting function.</p><pre><code class="language-julia hljs">function shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

    p0 = [-1, pz0]

    q1_, p1_ = f1(t0, q0, p0, t1)
    q2_, p2_ = fs(t1, q1, p1, t2)
    q3_, p3_ = f1(t2, q2, p2, t3)
    qf , pf  = f0(t3, q3, p3, tf)

    s[1] = - p1[1] ⋅ zs + p1[2] ⋅ q1[1]   # H1 = H01 = 0 on the horizontal
    s[2] = q1[2] - zs                     # singular line, z=zs
    s[3] = p3[1]                          # H1 = H01 = 0 on the vertical
    s[4] = q3[1]                          # singular line, y=0
    s[5] = qf[2]                          # z(tf) = 0

    # matching conditions
    s[ 6: 7] = q1 - q1_
    s[ 8: 9] = p1 - p1_
    s[10:11] = q2 - q2_
    s[12:13] = p2 - p2_
    s[14:15] = q3 - q3_
    s[16:17] = p3 - p3_

end</code></pre><p>We are now in position to solve the shooting equations. Due to the sensitivity of the first singular arc, we need to improve the initial guess obtained from the direct method to make the Newton solver converge. To do so, we set for the initial guess <span>$z(t_1) = z_s$</span> and <span>$p_z(t_1) = p_y(t_1) z_s / y(t_1)$</span>.</p><p>We can see below from the norm of the shooting function that the initial guess is not very accurate.</p><pre><code class="language-julia hljs"># we refine the initial guess to make the Newton solver converge
q1[2] = zs
p1[2] = p1[1] ⋅ zs / q1[1]

# Norm of the shooting function at initial guess
using LinearAlgebra: norm

s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Norm of the shooting function: ‖s‖ = 18.361555100489344</code></pre><p>We can use the <a href="https://github.com/sglyon/MINPACK.jl">MINPACK.jl</a> package to solve the shooting equation. To compute the Jacobian of the shooting function we use the <a href="https://juliadiff.org/DifferentiationInterface.jl/DifferentiationInterface">DifferentiationInterface.jl</a> package with <a href="https://juliadiff.org/ForwardDiff.jl">ForwardDiff.jl</a> backend.</p><pre><code class="language-julia hljs">using DifferentiationInterface
import ForwardDiff
backend = AutoForwardDiff()</code></pre><p>Let us define the problem to solve.</p><pre><code class="language-julia hljs"># auxiliary function with aggregated inputs
shoot!(s, ξ) = shoot!(s, ξ[1], ξ[2:5]..., ξ[6:7], ξ[8:9],
    ξ[10:11], ξ[12:13], ξ[14:15], ξ[16:17])

# Jacobian of the (auxiliary) shooting function
jshoot!(js, ξ) = jacobian!(shoot!, similar(ξ), js, backend, ξ)</code></pre><p>We are now in position to solve the problem with the <code>hybrj</code> solver from MINPACK.jl through the <code>fsolve</code> function, providing the Jacobian. Let us solve the problem and retrieve the initial contate and the times (switching and final) from the solution.</p><pre><code class="language-julia hljs">using MINPACK

# initial guess
ξ = [ pz0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3]

# resolution of S(ξ) = 0
indirect_sol = fsolve(shoot!, jshoot!, ξ, show_trace=true)

# we retrieve the costate solution together with the times
pz0 = indirect_sol.x[1]
t1 = indirect_sol.x[2]
t2 = indirect_sol.x[3]
t3 = indirect_sol.x[4]
tf = indirect_sol.x[5]
q1 = indirect_sol.x[6:7]
p1 = indirect_sol.x[8:9]
q2 = indirect_sol.x[10:11]
p2 = indirect_sol.x[12:13]
q3 = indirect_sol.x[14:15]
p3 = indirect_sol.x[16:17]

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)

# Norm of the shooting function at solution
s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     f(x) inf-norm    Step 2-norm      Step time
------   --------------   --------------   --------------
     1     1.729122e+01     0.000000e+00         0.613360
     2     9.461468e-01     3.704268e+01        32.138990
     3     2.839417e-01     7.649105e+00         0.004132
     4     2.196746e-01     6.189414e+00         0.004048
     5     4.899687e-02     1.555075e+01         0.004012
     6     1.317601e-01     6.220299e+01         0.003937
     7     3.647552e-01     1.399561e+02         0.004234
     8     4.266673e-02     3.889313e+00         0.058774
     9     1.862372e-01     1.555075e+01         0.004197
    10     3.906691e-02     3.889347e+00         0.004719
    11     6.814071e-02     3.887687e+00         0.004175
    12     1.408918e-02     9.722099e-01         0.004182
    13     4.460910e-02     3.887687e+00         0.004227
    14     9.719317e-03     9.720021e-01         0.004130
    15     4.894523e-02     3.887687e+00         0.004521
    16     1.037975e-02     9.720452e-01         0.005888
    17     1.722110e-02     9.719218e-01         0.005889
    18     3.374491e-03     2.429959e-01         0.005998
    19     1.050803e-02     9.719218e-01         0.005857
    20     2.514214e-03     2.429847e-01         0.006019
    21     1.236260e-02     9.719218e-01         0.024863
    22     2.699892e-03     2.429877e-01         0.004061
    23     4.405108e-03     2.429804e-01         0.004010
    24     1.140801e-03     6.074605e-02         0.003999
    25     2.529561e-03     2.429804e-01         0.004060
    26     8.971382e-04     6.074537e-02         0.004037
    27     3.105367e-03     2.429804e-01         0.004036
    28     6.886897e-04     6.074555e-02         0.004060
    29     1.114999e-03     6.074511e-02         0.004021
    30     5.937321e-04     1.518634e-02         0.004018
    31     6.886842e-04     6.074511e-02         0.004026
    32     5.243157e-04     1.518629e-02         0.004169
    33     7.780883e-04     6.074511e-02         0.004130
    34     4.570424e-04     1.518630e-02         0.005032
    35     7.861590e-04     6.074511e-02         0.006100
    36     3.925009e-04     1.518631e-02         0.006004
    37     7.834904e-04     6.074511e-02         0.016242
    38     3.308893e-04     1.518631e-02         0.004030
    39     7.850448e-04     6.074511e-02         0.004052
    40     2.723456e-04     1.518631e-02         0.004045
    41     7.867550e-04     6.074511e-02         0.004138
    42     2.170459e-04     1.518631e-02         0.004220
    43     7.883592e-04     6.074511e-02         0.004187
    44     1.793299e-04     1.518631e-02         0.004063
    45     7.899762e-04     6.074511e-02         0.004045
    46     1.787759e-04     1.518631e-02         0.004067
    47     2.839177e-04     1.518628e-02         0.004153
    48     1.589777e-04     3.796573e-03         0.004190
    49     1.503008e-04     1.518628e-02         0.004102
    50     1.506639e-04     3.796570e-03         0.012601
    51     1.968768e-04     1.518628e-02         0.004074
    52     1.424838e-04     3.796571e-03         0.004002
    53     1.995271e-04     1.518628e-02         0.004084
    54     1.342526e-04     3.796571e-03         0.004027
    55     1.981819e-04     1.518628e-02         0.004056
    56     1.259569e-04     3.796571e-03         0.004052
    57     1.983571e-04     1.518628e-02         0.004077
    58     1.175940e-04     3.796571e-03         0.004024
    59     1.986120e-04     1.518628e-02         0.004002
    60     1.091543e-04     3.796571e-03         0.004010
    61     1.988165e-04     1.518628e-02         0.004080
    62     1.006264e-04     3.796571e-03         0.010773
    63     1.990215e-04     1.518628e-02         0.004130
    64     9.199662e-05     3.796571e-03         0.004041
    65     7.942206e-05     3.796569e-03         0.004094
    66     8.723076e-05     9.491426e-04         0.004211
    67     7.506890e-05     3.796569e-03         0.004206
    68     1.671472e-04     1.518628e-02         0.004115
    69     6.666613e-05     3.796571e-03         0.004072
    70     6.134117e-05     9.491423e-04         0.027986
    71     4.993157e-05     3.796569e-03         0.004083
    72     5.647322e-05     9.491424e-04         0.003975
    73     4.774480e-05     3.796569e-03         0.004009
    74     5.160141e-05     9.491424e-04         0.004028
    75     4.774434e-05     3.796569e-03         0.009425
    76     4.672440e-05     9.491424e-04         0.004059
    77     4.776050e-05     3.796569e-03         0.004066
    78     4.183995e-05     9.491424e-04         0.004068
    79     4.777701e-05     3.796569e-03         0.004232
    80     3.694530e-05     9.491424e-04         0.004220
    81     4.779395e-05     3.796569e-03         0.004111
    82     3.203693e-05     9.491424e-04         0.004125
    83     4.781139e-05     3.796569e-03         0.004049
    84     2.711018e-05     9.491424e-04         0.004155
    85     4.782921e-05     3.796569e-03         0.004217
    86     2.215861e-05     9.491424e-04         0.011954
    87     4.784746e-05     3.796569e-03         0.004099
    88     1.717278e-05     9.491424e-04         0.004003
    89     4.786615e-05     3.796569e-03         0.003984
    90     1.213745e-05     9.491424e-04         0.004085
    91     4.788530e-05     3.796569e-03         0.004089
    92     8.099735e-06     9.491424e-04         0.004047
    93     2.324557e-05     1.548720e-03         0.004034
    94     2.321026e-06     7.302771e-05         0.004008
    95     2.874311e-06     7.491454e-05         0.003990
    96     1.820909e-08     1.764393e-10         0.004026
    97     4.602427e-09     9.546174e-12         0.010700
    98     2.378469e-12     3.583026e-13         0.004049
pz0 = -10.103027162172843
t1 = 1.6450509469600776
t2 = 37.323981285581745
t3 = 37.58077357861729
tf = 42.71370875363171
Norm of the shooting function: ‖s‖ = 2.6791056126541833e-12</code></pre><p>Let us plot the solution from the indirect method. We can notice that the second bang arc is well captured by the indirect method compared to the direct method.</p><pre><code class="language-julia hljs"># concatenation of the flows with the switching times
f = f1 * (t1, fs) * (t2, f1) * (t3, f0)

# computation of the solution: state, costate, control
indirect_sol = f((t0, tf), q0, [-1, pz0])

# plot in the Bloch ball
spin_plot(indirect_sol; size=(800, 400))</code></pre><img src="saturation-020ce0cc.svg" alt="Example block output"/><p>From the following plot, we can conclude that the maximisation condition from the PMP is now well satisfied compared to the solution obtained from the direct method.</p><pre><code class="language-julia hljs">plt = switching_plot(indirect_sol, H1, H01; size=(700, 800))
lens!(plt, [37.2, 37.7], [    0, 4e-5], inset = (1, bbox(0.3, 0.2, 0.3, 0.4)))
lens!(plt, [37.2, 37.7], [-5e-4, 5e-4], inset = (2, bbox(0.3, 0.3, 0.3, 0.4)))
lens!(plt, [37.2, 37.7], [  0.5,  1.1], inset = (3, bbox(0.3, 0.2, 0.3, 0.4)))</code></pre><img src="saturation-1c8a8826.svg" alt="Example block output"/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>B. Bonnard, O. Cots, S. Glaser, M. Lapert, D. Sugny &amp; Y. Zhang, *Geometric optimal control of the contrast imaging problem in nuclear magnetic resonance, IEEE Trans. Automat. Control, <strong>57</strong> (2012), no. 8, 1957–1969.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bonnard, B.; Cots, O.; Rouot, J.; Verron, T. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88. https://inria.hal.science/hal-01779377</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="bloch-equation.html">« Bloch equation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 29 September 2025 13:16">Monday 29 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
